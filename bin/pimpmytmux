#!/usr/bin/env bash
# pimpmytmux - A modern, modular tmux configuration
# https://github.com/christopherlouet/pimpmytmux

set -euo pipefail

# -----------------------------------------------------------------------------
# Initialization
# -----------------------------------------------------------------------------

# Determine the script location and project root (resolve symlinks)
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
export PIMPMYTMUX_ROOT="${PIMPMYTMUX_ROOT:-$(cd "$SCRIPT_DIR/.." && pwd)}"
export PIMPMYTMUX_LIB_DIR="${PIMPMYTMUX_ROOT}/lib"

# Source core library first (required for load_module)
source "${PIMPMYTMUX_LIB_DIR}/core.sh"

# Load required libraries using explicit loading
load_lib "config" "required"
load_lib "validation" "optional"
load_lib "backup" "optional"
load_lib "preview" "optional"
load_lib "gallery" "optional"
load_lib "profiles" "optional"
load_lib "detect" "optional"
load_lib "wizard" "optional"

# Load session modules (optional)
load_module "${PIMPMYTMUX_ROOT}/modules/sessions/save.sh" "optional"
load_module "${PIMPMYTMUX_ROOT}/modules/sessions/restore.sh" "optional"
load_module "${PIMPMYTMUX_ROOT}/modules/sessions/layouts.sh" "optional"

# -----------------------------------------------------------------------------
# CLI Configuration
# -----------------------------------------------------------------------------

PIMPMYTMUX_CONFIG_FILE="${PIMPMYTMUX_CONFIG_FILE:-${PIMPMYTMUX_CONFIG_DIR}/pimpmytmux.yaml}"
DRY_RUN=false

# -----------------------------------------------------------------------------
# Help & Usage
# -----------------------------------------------------------------------------

show_version() {
    echo "pimpmytmux v${PIMPMYTMUX_VERSION}"
}

show_help() {
    cat << EOF
${BOLD}pimpmytmux${RESET} - A modern, modular tmux configuration

${BOLD}USAGE:${RESET}
    pimpmytmux <command> [options]

${BOLD}COMMANDS:${RESET}
    apply           Generate and apply tmux configuration
    reload          Reload tmux configuration (inside tmux)
    theme <name>    Switch to a different theme (--preview to preview)
    themes          List available themes (--gallery for visual)
    profile <cmd>   Profile management (list, switch, create, delete)
    session <cmd>   Session management (save, restore, list)
    layout <name>   Apply a predefined layout (--preview to preview)
    layouts         List available layouts
    zen [on|off]    Toggle zen mode (hide status bar + borders)
    backup <cmd>    Backup management (list, restore, create, cleanup)
    detect [path]   Detect project type and show info
    edit            Open configuration file in editor
    check           Validate configuration file
    status          Show current pimpmytmux status
    init            Initialize pimpmytmux (create config if missing)
    wizard          Interactive setup wizard
    setup           Quick setup with defaults
    help            Show this help message
    version         Show version

${BOLD}OPTIONS:${RESET}
    -c, --config <file>    Use custom config file
    -v, --verbose          Enable verbose output
    -d, --debug            Enable debug output
    --dry-run              Show what would be done without doing it
    --no-backup            Skip automatic backup before apply
    --no-notifications     Disable tmux status bar notifications
    -q, --quiet            Suppress non-error output
    -h, --help             Show help for a command

${BOLD}EXAMPLES:${RESET}
    pimpmytmux apply                  # Generate and apply config
    pimpmytmux theme cyberpunk        # Switch to cyberpunk theme
    pimpmytmux session save mywork    # Save current session
    pimpmytmux session restore mywork # Restore saved session
    pimpmytmux layout dev-fullstack   # Apply fullstack dev layout
    pimpmytmux wizard                 # Run interactive setup wizard
    pimpmytmux setup                  # Quick setup with defaults
    pimpmytmux edit                   # Edit configuration
    pimpmytmux check                  # Validate config file

${BOLD}FILES:${RESET}
    Config:    ${PIMPMYTMUX_CONFIG_DIR}/pimpmytmux.yaml
    Generated: ${PIMPMYTMUX_CONFIG_DIR}/tmux.conf

For more information, visit: https://github.com/christopherlouet/pimpmytmux
EOF
}

# -----------------------------------------------------------------------------
# Commands
# -----------------------------------------------------------------------------

## Initialize pimpmytmux - create directories and example config
cmd_init() {
    log_info "Initializing pimpmytmux..."

    # Create directories
    init_directories

    # Copy example config if not exists
    if [[ ! -f "$PIMPMYTMUX_CONFIG_FILE" ]]; then
        local example="${PIMPMYTMUX_ROOT}/pimpmytmux.yaml.example"
        if [[ -f "$example" ]]; then
            cp "$example" "$PIMPMYTMUX_CONFIG_FILE"
            log_success "Created config: $PIMPMYTMUX_CONFIG_FILE"
        else
            log_warn "Example config not found, creating minimal config"
            cat > "$PIMPMYTMUX_CONFIG_FILE" << 'EOF'
# pimpmytmux configuration
theme: cyberpunk

general:
  prefix: C-b
  mouse: true
  base_index: 1

modules:
  sessions:
    enabled: true
  navigation:
    enabled: true
    vim_mode: true
  monitoring:
    enabled: true
EOF
            log_success "Created minimal config: $PIMPMYTMUX_CONFIG_FILE"
        fi
    else
        log_info "Config already exists: $PIMPMYTMUX_CONFIG_FILE"
    fi

    log_success "pimpmytmux initialized!"
    log_info "Run 'pimpmytmux apply' to generate tmux configuration"
}

## Apply configuration - generate tmux.conf and optionally reload
cmd_apply() {
    local no_backup="${NO_BACKUP:-false}"

    log_info "Applying pimpmytmux configuration..."

    # Check if config exists
    if [[ ! -f "$PIMPMYTMUX_CONFIG_FILE" ]]; then
        error_with_suggestion "Config file not found: $PIMPMYTMUX_CONFIG_FILE" \
            "Run 'pimpmytmux init' to create a default config"
        exit 1
    fi

    # Generate configuration to temp file first
    local output_file temp_file
    output_file=$(get_tmux_conf_path)
    temp_file=$(mktemp)

    log_verbose "Generating configuration to temporary file..."

    if ! generate_tmux_conf "$PIMPMYTMUX_CONFIG_FILE" "$temp_file" "false"; then
        rm -f "$temp_file"
        log_error "Failed to generate configuration"
        exit 1
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Dry run mode - showing changes"
        echo ""

        local current_conf
        current_conf=$(get_tmux_conf_path)

        if [[ -f "$current_conf" ]]; then
            # Show colored diff
            if check_command preview_tmux_conf_diff; then
                preview_tmux_conf_diff "$temp_file"
                echo ""
            fi

            echo -e "${BOLD}Configuration diff:${RESET}"
            echo ""

            # Show diff with colors
            if check_command colordiff; then
                diff -u "$current_conf" "$temp_file" | colordiff || true
            else
                diff -u "$current_conf" "$temp_file" 2>/dev/null | while IFS= read -r line; do
                    case "$line" in
                        +*) echo -e "${GREEN}${line}${RESET}" ;;
                        -*) echo -e "${RED}${line}${RESET}" ;;
                        @*) echo -e "${CYAN}${line}${RESET}" ;;
                        *)  echo "$line" ;;
                    esac
                done || true
            fi
        else
            echo -e "${BOLD}New configuration (no existing tmux.conf):${RESET}"
            echo ""
            cat "$temp_file"
        fi

        rm -f "$temp_file"
        echo ""
        log_info "Run 'pimpmytmux apply' to apply these changes"
        return 0
    fi

    # Validate the generated configuration
    log_verbose "Validating generated configuration..."

    if is_module_loaded "validation" || [[ -n "${_PIMPMYTMUX_VALIDATION_LOADED:-}" ]]; then
        if ! validate_before_apply "$temp_file"; then
            rm -f "$temp_file"
            log_error_detail "Configuration validation failed" \
                "The generated tmux.conf contains errors.\nPlease check your pimpmytmux.yaml configuration."
            exit 1
        fi
        log_verbose "Configuration validated successfully"
    else
        log_debug "Validation module not loaded, skipping validation"
    fi

    # Backup existing configuration (unless disabled)
    if [[ "$no_backup" != "true" ]]; then
        if is_module_loaded "backup" || [[ -n "${_PIMPMYTMUX_BACKUP_LOADED:-}" ]]; then
            local backup_path
            backup_path=$(backup_before_apply)
            if [[ -n "$backup_path" ]]; then
                log_verbose "Backed up existing config"
            fi
        else
            log_debug "Backup module not loaded, skipping backup"
        fi
    fi

    # Move temp file to final destination
    ensure_dir "$(dirname "$output_file")"
    mv "$temp_file" "$output_file"
    log_verbose "Generated: $output_file"

    # Setup symlink
    setup_tmux_conf_symlink

    # Reload if inside tmux
    if is_inside_tmux; then
        reload_tmux
        tmux_notify "Configuration applied!" "success"
    else
        log_info "Not inside tmux. Start tmux to use the new configuration."
    fi

    log_success "Configuration applied!"
}

## Reload tmux configuration
cmd_reload() {
    if ! is_inside_tmux; then
        log_error "Not inside a tmux session"
        exit 1
    fi

    reload_tmux
    tmux_notify "Configuration reloaded!" "success"
}

## Switch theme
cmd_theme() {
    local theme_name=""
    local preview_mode=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --preview|-p)
                preview_mode=true
                shift
                ;;
            *)
                theme_name="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$theme_name" ]]; then
        log_error "Theme name required"
        log_info "Usage: pimpmytmux theme <name> [--preview]"
        log_info "Run 'pimpmytmux themes' to list available themes"
        exit 1
    fi

    # Check if theme exists
    local theme_file="${PIMPMYTMUX_ROOT}/themes/${theme_name}.yaml"
    if [[ ! -f "$theme_file" ]]; then
        log_error "Theme not found: $theme_name"
        log_info "Run 'pimpmytmux themes' to list available themes"
        exit 1
    fi

    # Preview mode - just show theme preview
    if [[ "$preview_mode" == "true" ]]; then
        if check_command preview_theme; then
            preview_theme "$theme_name"
        else
            log_error "Preview not available (lib/preview.sh not loaded)"
            exit 1
        fi
        return 0
    fi

    # Update config file to use new theme
    if check_command yq; then
        local yq_type
        yq_type=$(detect_yq_version)

        if [[ "$yq_type" == "go" ]]; then
            yq eval -i ".theme = \"$theme_name\"" "$PIMPMYTMUX_CONFIG_FILE"
        else
            log_warn "yq Python version detected, manual edit required"
            log_info "Edit $PIMPMYTMUX_CONFIG_FILE and set: theme: $theme_name"
            exit 1
        fi
    else
        log_warn "yq not installed, using sed fallback"
        sed -i.bak "s/^theme:.*/theme: $theme_name/" "$PIMPMYTMUX_CONFIG_FILE"
    fi

    log_success "Theme changed to: $theme_name"

    # Re-apply configuration
    cmd_apply
}

## List available themes
cmd_themes() {
    local gallery_mode=false
    local interactive_mode=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --gallery|-g)
                gallery_mode=true
                shift
                ;;
            --interactive|-i)
                interactive_mode=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Interactive mode with gum
    if [[ "$interactive_mode" == "true" ]]; then
        if check_command select_theme_interactive; then
            select_theme_interactive
        else
            log_warn "Gallery module not loaded"
            gallery_mode=true
        fi
    fi

    # Gallery mode
    if [[ "$gallery_mode" == "true" ]]; then
        if check_command show_gallery; then
            show_gallery
        else
            log_warn "Gallery not available, showing simple list"
        fi
        return 0
    fi

    # Default: simple list
    echo -e "${BOLD}Available themes:${RESET}"
    echo ""

    local themes_dir="${PIMPMYTMUX_ROOT}/themes"

    if [[ ! -d "$themes_dir" ]]; then
        log_warn "Themes directory not found: $themes_dir"
        return 1
    fi

    # Get current theme
    local current_theme
    current_theme=$(get_config ".theme" "")

    for theme_file in "$themes_dir"/*.yaml; do
        if [[ -f "$theme_file" ]]; then
            local name
            name=$(basename "$theme_file" .yaml)

            if [[ "$name" == "$current_theme" ]]; then
                echo -e "  ${GREEN}*${RESET} ${BOLD}$name${RESET} (current)"
            else
                echo "    $name"
            fi
        fi
    done

    echo ""
    echo "Switch theme with: pimpmytmux theme <name>"
    echo "Show gallery with: pimpmytmux themes --gallery"
}

## Edit configuration
cmd_edit() {
    local editor="${EDITOR:-${VISUAL:-vim}}"

    if [[ ! -f "$PIMPMYTMUX_CONFIG_FILE" ]]; then
        log_warn "Config file not found, creating..."
        cmd_init
    fi

    log_info "Opening $PIMPMYTMUX_CONFIG_FILE with $editor"
    "$editor" "$PIMPMYTMUX_CONFIG_FILE"

    # Ask to apply changes
    if [[ -t 0 ]]; then  # Interactive terminal
        read -rp "Apply changes? [y/N] " answer
        if [[ "$answer" =~ ^[Yy]$ ]]; then
            cmd_apply
        fi
    fi
}

## Check/validate configuration
cmd_check() {
    log_info "Checking configuration..."

    if [[ ! -f "$PIMPMYTMUX_CONFIG_FILE" ]]; then
        log_error "Config file not found: $PIMPMYTMUX_CONFIG_FILE"
        exit 1
    fi

    if validate_config "$PIMPMYTMUX_CONFIG_FILE"; then
        log_success "Configuration is valid"

        # Show some info
        echo ""
        echo -e "${BOLD}Configuration summary:${RESET}"
        echo "  Theme:  $(get_config '.theme' 'default')"
        echo "  Prefix: $(get_config '.general.prefix' 'C-b')"
        echo "  Mouse:  $(get_config '.general.mouse' 'true')"

        # List enabled modules
        echo ""
        echo -e "${BOLD}Enabled modules:${RESET}"
        for module in sessions navigation devtools monitoring; do
            if config_enabled ".modules.${module}.enabled"; then
                echo -e "  ${GREEN}+${RESET} $module"
            else
                echo -e "  ${DIM}-${RESET} $module"
            fi
        done
    else
        log_error "Configuration has errors"
        exit 1
    fi
}

## Show status
cmd_status() {
    echo -e "${BOLD}pimpmytmux status${RESET}"
    echo ""

    # Version
    echo "Version:    v${PIMPMYTMUX_VERSION}"

    # Platform
    echo "Platform:   $(get_platform)"

    # tmux version
    if check_command tmux; then
        echo "tmux:       $(tmux -V)"
    else
        echo "tmux:       ${RED}not installed${RESET}"
    fi

    # Config file
    if [[ -f "$PIMPMYTMUX_CONFIG_FILE" ]]; then
        echo "Config:     ${GREEN}$PIMPMYTMUX_CONFIG_FILE${RESET}"
    else
        echo "Config:     ${YELLOW}not found${RESET}"
    fi

    # Generated config
    local generated
    generated=$(get_tmux_conf_path)
    if [[ -f "$generated" ]]; then
        echo "Generated:  ${GREEN}$generated${RESET}"
    else
        echo "Generated:  ${YELLOW}not found${RESET}"
    fi

    # Inside tmux?
    if is_inside_tmux; then
        echo "Session:    ${GREEN}inside tmux${RESET}"
    else
        echo "Session:    outside tmux"
    fi

    # Dependencies
    echo ""
    echo -e "${BOLD}Dependencies:${RESET}"
    for dep in yq fzf gum; do
        if check_command "$dep"; then
            echo -e "  ${GREEN}+${RESET} $dep"
        else
            echo -e "  ${DIM}-${RESET} $dep (optional)"
        fi
    done
}

## Backup management command
cmd_backup() {
    local subcmd="${1:-}"
    shift || true

    case "$subcmd" in
        list)
            echo -e "${BOLD}Configuration backups:${RESET}"
            echo ""
            list_backups
            ;;
        restore)
            local backup_file="${1:-}"
            if [[ -z "$backup_file" ]]; then
                # Try to get latest backup
                backup_file=$(get_latest_backup)
                if [[ -z "$backup_file" ]]; then
                    log_error "No backups available"
                    exit 1
                fi
                log_info "Restoring latest backup: $(basename "$backup_file")"
            fi
            restore_backup "$backup_file"
            ;;
        create)
            backup_config
            ;;
        cleanup)
            local keep="${1:-5}"
            cleanup_old_backups "$keep"
            ;;
        "")
            log_error "Subcommand required"
            echo ""
            echo "Usage: pimpmytmux backup <command>"
            echo ""
            echo "Commands:"
            echo "    list              List available backups"
            echo "    restore [file]    Restore a backup (latest if no file specified)"
            echo "    create            Create a manual backup"
            echo "    cleanup [n]       Keep only last n backups (default: 5)"
            exit 1
            ;;
        *)
            log_error "Unknown backup command: $subcmd"
            exit 1
            ;;
    esac
}

## Profile management command
cmd_profile() {
    local subcmd="${1:-}"
    shift || true

    # Initialize profiles if needed
    if check_command init_profiles; then
        init_profiles
    fi

    case "$subcmd" in
        list)
            local current
            current=$(get_current_profile 2>/dev/null || echo "default")
            echo -e "${BOLD}Available profiles:${RESET}"
            echo ""
            while IFS= read -r profile; do
                if [[ -n "$profile" ]]; then
                    if [[ "$profile" == "$current" ]]; then
                        echo -e "  ${GREEN}* $profile${RESET} (current)"
                    else
                        echo "    $profile"
                    fi
                fi
            done < <(list_profiles)
            echo ""
            ;;
        switch)
            local name="${1:-}"
            if [[ -z "$name" ]]; then
                log_error "Profile name required"
                log_info "Usage: pimpmytmux profile switch <name>"
                exit 1
            fi
            switch_profile "$name"
            # Re-apply configuration with new profile
            log_info "Re-applying configuration with profile: $name"
            PIMPMYTMUX_CONFIG_FILE=$(get_active_config_path)
            cmd_apply
            ;;
        create)
            local name="${1:-}"
            shift || true
            if [[ -z "$name" ]]; then
                log_error "Profile name required"
                log_info "Usage: pimpmytmux profile create <name> [--from <source>]"
                exit 1
            fi
            create_profile "$name" "$@"
            ;;
        delete)
            local name="${1:-}"
            if [[ -z "$name" ]]; then
                log_error "Profile name required"
                log_info "Usage: pimpmytmux profile delete <name>"
                exit 1
            fi
            # Confirm deletion
            echo -n "Delete profile '$name'? [y/N] "
            read -r confirm
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                delete_profile "$name"
            else
                log_info "Cancelled"
            fi
            ;;
        "")
            log_error "Subcommand required"
            echo ""
            echo "Usage: pimpmytmux profile <command>"
            echo ""
            echo "Commands:"
            echo "    list                    List available profiles"
            echo "    switch <name>           Switch to a profile"
            echo "    create <name> [--from]  Create a new profile"
            echo "    delete <name>           Delete a profile"
            echo ""
            echo "Examples:"
            echo "    pimpmytmux profile list"
            echo "    pimpmytmux profile create work --from default"
            echo "    pimpmytmux profile switch work"
            exit 1
            ;;
        *)
            log_error "Unknown profile command: $subcmd"
            exit 1
            ;;
    esac
}

## Detect project type and show info
cmd_detect() {
    local dir="${1:-$(pwd)}"
    local apply_layout=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --apply)
                apply_layout=true
                shift
                ;;
            *)
                dir="$1"
                shift
                ;;
        esac
    done

    if ! check_command detect_project_type; then
        log_error "Project detection not available (lib/detect.sh not loaded)"
        exit 1
    fi

    local type
    type=$(detect_project_type "$dir")

    if [[ "$type" == "unknown" ]]; then
        log_warn "Could not detect project type in: $dir"
        log_info "Supported project types:"
        list_project_types
        exit 1
    fi

    # Show project info
    show_project_info "$dir"

    # Apply layout if requested
    if [[ "$apply_layout" == "true" ]]; then
        if ! is_inside_tmux; then
            log_error "Must be inside tmux to apply layout"
            exit 1
        fi
        apply_project_layout "$dir"
    fi
}

## Session management command
cmd_session() {
    local subcmd="${1:-}"
    shift || true

    case "$subcmd" in
        save)
            local name="${1:-}"
            if [[ -z "$name" ]]; then
                log_error "Session name required"
                log_info "Usage: pimpmytmux session save <name>"
                exit 1
            fi
            if ! is_inside_tmux; then
                log_error "Must be inside tmux to save session"
                exit 1
            fi
            save_session "$name"
            ;;
        restore)
            local name="${1:-}"
            if [[ -z "$name" ]]; then
                log_error "Session name required"
                log_info "Usage: pimpmytmux session restore <name>"
                exit 1
            fi
            restore_session "$name"
            ;;
        list)
            list_saved_sessions
            ;;
        "")
            log_error "Subcommand required"
            echo ""
            echo "Usage: pimpmytmux session <command>"
            echo ""
            echo "Commands:"
            echo "    save <name>     Save current session"
            echo "    restore <name>  Restore a saved session"
            echo "    list            List saved sessions"
            exit 1
            ;;
        *)
            log_error "Unknown session command: $subcmd"
            exit 1
            ;;
    esac
}

## Layout command
cmd_layout() {
    local layout_name=""
    local preview_mode=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --preview|-p)
                preview_mode=true
                shift
                ;;
            *)
                layout_name="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$layout_name" ]]; then
        log_error "Layout name required"
        log_info "Usage: pimpmytmux layout <name> [--preview]"
        log_info "Run 'pimpmytmux layouts' to list available layouts"
        exit 1
    fi

    # Preview mode - just show layout preview
    if [[ "$preview_mode" == "true" ]]; then
        if check_command preview_layout; then
            preview_layout "$layout_name"
        else
            log_error "Preview not available (lib/preview.sh not loaded)"
            exit 1
        fi
        return 0
    fi

    if ! is_inside_tmux; then
        log_error "Must be inside tmux to apply layout"
        exit 1
    fi

    apply_layout "$layout_name"
}

## List available layouts
cmd_layouts() {
    echo -e "${BOLD}Available layouts:${RESET}"
    echo ""

    local templates_dir="${PIMPMYTMUX_ROOT}/templates"

    if [[ ! -d "$templates_dir" ]]; then
        log_warn "Templates directory not found: $templates_dir"
        return 1
    fi

    for layout_file in "$templates_dir"/*.yaml; do
        if [[ -f "$layout_file" ]]; then
            local name desc
            name=$(basename "$layout_file" .yaml)
            desc=$(yq_get "$layout_file" ".description" 2>/dev/null || echo "")

            echo -e "  ${CYAN}$name${RESET}"
            if [[ -n "$desc" ]]; then
                echo "      $desc"
            fi
        fi
    done

    echo ""
    echo "Apply layout with: pimpmytmux layout <name>"
}

## Zen mode toggle
cmd_zen() {
    local action="${1:-}"

    if ! is_inside_tmux; then
        log_error "Must be inside tmux to toggle zen mode"
        exit 1
    fi

    zen_toggle "$action"
}

# -----------------------------------------------------------------------------
# Argument Parsing
# -----------------------------------------------------------------------------

parse_args() {
    local command=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--config)
                PIMPMYTMUX_CONFIG_FILE="$2"
                shift 2
                ;;
            -v|--verbose)
                PIMPMYTMUX_VERBOSITY=2
                shift
                ;;
            -d|--debug)
                PIMPMYTMUX_VERBOSITY=3
                shift
                ;;
            -q|--quiet)
                PIMPMYTMUX_VERBOSITY=0
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --no-backup)
                NO_BACKUP=true
                shift
                ;;
            --no-notifications)
                PIMPMYTMUX_NOTIFICATIONS=false
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            -*)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                if [[ -z "$command" ]]; then
                    command="$1"
                    shift
                    break  # Remaining args go to command
                fi
                ;;
        esac
    done

    # Default to help if no command
    if [[ -z "$command" ]]; then
        show_help
        exit 0
    fi

    # Execute command
    case "$command" in
        apply)
            cmd_apply "$@"
            ;;
        reload)
            cmd_reload "$@"
            ;;
        theme)
            cmd_theme "$@"
            ;;
        themes|list-themes)
            cmd_themes "$@"
            ;;
        profile)
            cmd_profile "$@"
            ;;
        session)
            cmd_session "$@"
            ;;
        layout)
            cmd_layout "$@"
            ;;
        layouts|list-layouts)
            cmd_layouts "$@"
            ;;
        zen)
            cmd_zen "$@"
            ;;
        edit)
            cmd_edit "$@"
            ;;
        check|validate)
            cmd_check "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        backup)
            cmd_backup "$@"
            ;;
        detect)
            cmd_detect "$@"
            ;;
        init)
            cmd_init "$@"
            ;;
        wizard)
            run_wizard "$@"
            ;;
        setup|quick-setup)
            quick_setup "$@"
            ;;
        help)
            show_help
            ;;
        version)
            show_version
            ;;
        *)
            log_error "Unknown command: $command"
            show_help
            exit 1
            ;;
    esac
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    parse_args "$@"
}

main "$@"
